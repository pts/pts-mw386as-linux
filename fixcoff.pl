#!/bin/sh --
eval 'PERL_BADLANG=x;export PERL_BADLANG;exec perl -x "$0" "$@";exit 1'
#!perl  # Start marker used by perl -x.
+0 if 0;eval("\n\n\n\n".<<'__END__');die$@if$@;__END__

#
# fixcoff.pl: fix COFF object file generated by the Mark Williams 80386 assembler so that GNU Binutils (e.g. objdump(1) and ld(1)) can process it as PE/COFF (pe-i386)
# by pts@fazekas.hu at Sun Apr  7 19:48:40 CEST 2024
#

BEGIN { $^W = 1 }
use integer;
use strict;

die "Usage: $0 <filename.o>\n" if @ARGV != 1;

my $fn = $ARGV[0];
sub fnopenq($) { $_[0] =~ m@[-+.\w]@ ? $_[0] : "./" . $_[0] }
die "fatal: error opening: $fn\n" if !open(F, "+< " . fnopenq($fn));
binmode(F);
{ my $oldfd = select(F); $| = 1; select($oldfd); }  # Autoflush.
my $s;
die "fatal: object file to short: $fn\n" if read(F, $s, 0xb4) < 0xb4 - 0x28;
die "fatal: not a COFF object file: $fn\n" if vec($s, 0, 16) != 0x4c01;  # Check in big endian.
my $section_count = unpack("v", substr($s, 2, 2));
#die "fatal: must have 3 or 4 sections: $fn\n" if $section_count != 3 and $section_count != 4;
die "fatal: must have 3 sections: $fn\n" if $section_count != 3;  # .rodata would be next, but that's nut supported.
die "fatal: EOF in COFF section definitions: $fn\n" if length($s) < 0x14 + ($section_count * 0x28);
die "fatal: expected .text section" if substr($s, 0x1c - 8, 8) ne ".text\0\0\0";
die "fatal: expected .data section" if substr($s, 0x44 - 8, 8) ne ".data\0\0\0";
die "fatal: expected .bss section" if substr($s, 0x6c - 8, 8) ne ".bss\0\0\0\0";
die "fatal: expected .rodata section" if $section_count >= 4 and substr($s, 0x94 - 8, 8) ne ".rodata\0";

# https://stackoverflow.com/questions/78287296/binutils-objdump-reports-incorrect-section-sizes-in-coff-object
my $s0 = $s;
vec($s, 0x13, 8) |= 1;  # byte 0x13 |= 1;  # F_AR32WR. 32-bit little endian.
vec($s, 0x38 + 2, 8) |= 0x30;
vec($s, 0x38 + 3, 8) |= 0x60;  # dword 0x38 0x20 -> 0x60300020  # .text flags.
vec($s, 0x60 + 2, 8) |= 0x30;
vec($s, 0x60 + 3, 8) |= 0xc0;  # dword 0x60 0x40 -> 0xc0300040  # .data flags.
vec($s, 0x88 + 2, 8) |= 0x30;
vec($s, 0x88 + 3, 8) |= 0xc0;  # dword 0x88 0x80 -> 0xc0300080  # .bss flags.
vec($s, 0xb0 + 2, 8) |= 0x30 if $section_count >= 4;
vec($s, 0xb0 + 3, 8) |= 0x40 if $section_count >= 4;  # dword 0xb0 0x40 -> 0x40300040  # .rodata flags. (.rdata by MinGW as(1).)
# Even after fixit it, relocations are still wrong.
my $text_vaddr = unpack("V", substr($s, 0x1c + 4, 4));
vec($s, 0x1c >> 2, 32) = 0;  # .text paddr.  # Already 0.
vec($s, 0x20 >> 2, 32) = 0;  # .text vaddr.  # Already 0.
my $text_ofs = unpack("V", substr($s, 0x1c + 0xc, 4));
my $text_reloc_ofs = unpack("V", substr($s, 0x1c + 0x10, 4));
my $text_reloc_count = unpack("V", substr($s, 0x1c + 0x18, 4));
my $data_vaddr = unpack("V", substr($s, 0x44 + 4, 4));
vec($s, 0x44 >> 2, 32) = 0;  # .data paddr.
vec($s, 0x48 >> 2, 32) = 0;  # .data vaddr.
my $data_ofs = unpack("V", substr($s, 0x44 + 0xc, 4));
my $data_reloc_ofs = unpack("V", substr($s, 0x44 + 0x10, 4));
my $data_reloc_count = unpack("V", substr($s, 0x44 + 0x18, 4));
my $bss_vaddr = unpack("V", substr($s, 0x6c + 4, 4));
vec($s, 0x6c >> 2, 32) = 0;  # .bss paddr. By keeping it, .bss size is wrong.
vec($s, 0x70 >> 2, 32) = 0;  # .bss vaddr. By keeping it, .bss size is wrong.
vec($s, 0x94 >> 2, 32) = 0 if $section_count >= 4;  # .rodata paddr.
vec($s, 0x98 >> 2, 32) = 0 if $section_count >= 4;  # .rodata vaddr.
exit(0) if $s0 eq $s;  # Already fixed.
die if !seek(F, 0, 0);
die if !print(F $s);

sub fix_relocs($$$$) {
  my($reloc_ofs, $count, $ofs, $vaddrs) = @_;
  return if $count == 0;
  die "fatal: relocation count overflow\n" if $count < 0 or $count >= 214748364;  # Should be OK even if multiplied by 10.
  die "fatal: relocation ofs overflow\n" if $reloc_ofs < 0 or ($reloc_ofs >> 31) != 0;
  $count *= 10;
  my $r;
  die if !seek(F, $reloc_ofs, 0);
  die if read(F, $r, $count) != $count;
  for (my $i = 0; $i != $count; $i += 10) {
    my($vaddr, $symndx, $type) = unpack("VVv", substr($r, $i, 10));
    # RELOC_ADDR32=6, RELOC_REL32=0x14==20.
    #printf(STDERR "info: vaddr=0x%x symndx=0x%x type=0x%x\n", $vaddr, $symndx, $type);
    die sprintf("fatal: expected reloc type=0x6(RELOC_ADDR32), got 0x%x\n", $type) if $type != 6;
    die sprintf("fatal: expected symndx less than 0x%x, got 0x%x\n", scalar(@$vaddrs), $symndx) if @$vaddrs <= $symndx;
    my $delta = -($vaddrs->[$symndx] << 1);
    next if !$delta;
    #printf(STDERR "info: fix vaddr=0x%x delta=0x%x\n", $vaddr, $delta);
    die if !seek(F, $ofs + $vaddr, 0);
    my $d;
    die if read(F, $d, 4) != 4;
    my $d2 = pack("V", (unpack("V", $d) + $delta) & 0xffffffff);
    #printf(STDERR "info: fix vaddr=0x%x delta=0x%x d=0x%x d2=0x%x\n", $vaddr, $delta, unpack("V", $d), unpack("V", $d2));
    die if !seek(F, $ofs + $vaddr, 0);
    die if !print(F $d2);
  }
}

my $vaddrs = [$text_vaddr, $data_vaddr, $bss_vaddr];
fix_relocs($text_reloc_ofs, $text_reloc_count, $text_ofs, $vaddrs);
fix_relocs($data_reloc_ofs, $data_reloc_count, $data_ofs, $vaddrs);

die if !close(F);

__END__
